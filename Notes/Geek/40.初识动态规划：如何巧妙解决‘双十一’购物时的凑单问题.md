### 动态规划（Dynamic Programming）

动态规划比较适合用来解决最优问题，比如求最大值、最小值，它可以非常显著地降低时间复杂度，提高代码的执行效率。

#### 1. 理解动态规划

##### 1. 参考文献

-   [通过金矿模型介绍动态规划](https://www.cnblogs.com/SDJL/archive/2008/08/22/1274312.html)
-   [知乎：如何理解动态规划](https://www.zhihu.com/question/39948290)
-   [知乎：什么是动态规划？动态规划的意义是什么？](https://www.zhihu.com/question/23995189/answer/56259510)

##### 2. 思考动态规划（以金矿模型为例）

_子问题_：国王需要根据两个大臣以及第 9 座金矿（最后一个金矿，从 0 开始排序）的信息才能判断出最多能够开采出多少金子。为了解决自己面临的问题，他需要给别人制造另外 2 个问题，这两个问题就是子问题。

1. 思考动态规划的第一点：**最优子结构**

    国王相信这要两个大臣能够给出正确的答案（对于考虑能够开采出的金子数，最多的也就是最优的同时也就是正确的），加上自己的判断，就可以得出最终的正确的答案。我们把这种子问题最优时母问题通过优化选择后一定最优的情况叫做“最优子结构”。

2. 思考动态规划的第二点：**子问题重叠**

    所有人面对的都是同样的问题，即给你一定数量的人，给你一定数量的金矿，让你求出能够开采出的最多金子数。把这种母问题和子问题本质上是同一个问题的情况称为“子问题重叠”。然而问题中出现的不同点往往就是被子问题之间传递的参数，比如这里的人数和金矿数。

3. 思考动态规划的第三点：**边界**

    把这种子问题在一定时候就不再需要提出子问题的情况叫做边界，没有边界就会出现死循环。

4. 思考动态规划的第四点：**子问题独立**

    当国王的两位大臣在思考他们自己的问题时他们是不会去关心对方是如何计算怎么样开采金矿的，因为他们知道，国王只会选择两个人中的一个作为最后方案，另一个人的方案并不会得到实施，因此一个人的决定对另一个人的决定是没有影响的。我们把这种一个母问题在对子问题选择时，当前被选择的子问题两两互不影响的情况叫做“子问题独立”。

5. 思考动态规划的第五点：**做备忘录**

    当我们遇到相同的问题时，可以问同一个人。讲的通俗一点，我们可以把问题的解放在同一个变量中，如果再次遇到这个问题就直接从变量中获取答案，因此每一个问题仅会计算一遍，如果不做备忘录，动态规划就没有任何优势可言了。

6. 思考动态规划的第六点：**时间分析**

    非正式的，我们可以很容易得到动态规划所需时间。如果有 `questionCount` 个相同的子问题，而每个子问题需要面对 `chooseCount` 种选择，我们所需时间就为 `questionCount * chooseCount` 个常数。在金矿模型中，子问题最多大概有 `people * n` 个（其中 people 是用于开采金矿的总人数，n 是金矿的总数），因此 `questionCount = people * n`，就像国王采用左右两位部下的结果一样，每个问题面对两个选择，因此 `chooseCount = 2`，所以程序运行时间为 `T = O(questionCount * chooseCount) = O(people * n)`，实际上所需的时间小于这个值。

##### 3. 动态规划的思考角度（以金矿模型为例）

如果一个解决问题的方法满足上述 6 个思考点中的前 4 个，那么这个方法就属于动态规划。而在思考动态规划方法时，后 2 点同样也需要考虑。

面对问题要寻找动态规划的方法，首先要清楚一点，**动态规划不是算法，它是一种方法**，是在一件事情发生的过程中寻找最优值得防范，因此，我们需要对这件事情所发生的过程进行考虑。

通常，从过程的**最后一步**开始考虑，而不是先考虑过程的开始。过程的开始，也就是考虑的最后一步，就是**边界**。

因此，在遇到一个方法想用动态规划区解决时，不妨先思考一下这个过程是怎么样的，然后考虑过程的最后一步是如何选择的，通常我们需要自己去构造一个过程。

##### 4. 遇到问题如何用动态规划区解决？

根据上述分析，可以采取以下步骤去考虑：

1.  构造问题所对应的过程。
2.  思考过程的最后一个步骤。
3.  找到最后一步的子问题，确保符合“子问题重叠”，把子问题中的不相同的地方设置为参数。
4.  使得子问题符合“最优子结构”。
5.  找到边界，考虑边界的各种处理方式。
6.  确保满足“子问题独立”，一般而言，如何我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。
7.  考虑如何做备忘录。
8.  分析所需时间是否满足要求。
9.  写出转移方程。

##### 5. [代码示例：动态规划之金矿模型.js](/Algo/DP-GoldMine.js)

#### 2. 背包问题

-   [实例示意图](/MindMap/Geek/40.动态规划背包问题实例.jpg)

```java
// weight: 物品重量；n：物品个数；w：背包可承载重量
public int knapsack(int[] weight, int n, int w) {
    boolean[][] states = new boolean[n][w+1]; // 默认值false
    states[0][0] = true; // 第一行的数据要特殊处理，可以利用哨兵优化
    states[0][weight[0]] = true;
    for (int i = 1; i < n; ++i) { // 动态规划状态转移
        for (int j = 0; j <= w; ++j) { // 不把第i个物品放入背包
            if (states[i-1][j] == true) {
                states[i][j] = states[i-1][j]
            }
        }

        for (int j = 0; j <= w - weight[i]; ++j) { // 把第i个物品放入背包
            if (states[i-1][j] == true) {
                states[i][j+weight[i]] = true;
            }
        }
    }
    for (int i = w; i >= 0; --i) { // 输出结果
        if (states[n-1][i] == true) {
            return i
        }
    }
    return 0
}
```
