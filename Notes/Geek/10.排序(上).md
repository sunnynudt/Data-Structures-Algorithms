### 为什么插入排序比冒泡排序更受欢迎？

思考题：插入排序和冒泡排序的时间复杂度相同，都是 O(n^2)，在实际软件开发中，为什么还是更倾向于使用插入排序算法，而不是冒泡排序算法呢？

#### 1. 如何分析一个“排序算法”？

##### 1. 排序算法的执行效率？

1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数、低阶
3. 比较次数和交换（或移动）次数

##### 2. 排序算法的内存消耗

算法的内存消耗，可以通过空间复杂度来衡量。针对排序算法的空间复杂度，引入了一个新的概念，**原地排序(Sorted in place)**。原地排序算法，就是特指空间复杂度是 O(1)的排序算法。

##### 3. 排序算法的稳定性

稳定性，如果待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变。

#### 2. 冒泡排序(Bubble Sort)

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足，就让他俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。[冒泡排序的列子](/MindMap/Geek/10.冒泡排序示意图.jpg)。实际上，可以对刚才例子展示的冒泡过程进行优化，当某次冒泡操作已经没有数据交换了，就说明已经达到完全有序，不用再继续执行后续的冒泡操作。比如[下面例子](/MindMap/Geek/10.冒泡排序的优化.jpg)，给 6 个元素排序，只需要 4 次冒泡操作就可以了。

```java
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
    if(n <= 1) return;

    for(int i = 0; i < n; ++i) {
        // 提前退出循环冒泡的标志位
        boolean flag = false;
        for (int j = 0; j < n - i - 1; ++j) {
            if(a[j] > a[j+1]) { // 交换
                int tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
                flag = true; //表示有数据叫唤呢
            }
        }
        if(!flag) break; // 没有数据交换，提前退出
    }
}
```

##### 1. 冒泡排序是原地排序算法吗？

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以空间复杂度为 O(1)，是一个原地排序算法。

##### 2. 冒泡排序是稳定的排序算法吗？

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

##### 3. 冒泡排序的时间复杂度时多少？

最好情况下，数据是有序的，只需要进行一次冒泡排序，所以**最好情况时间复杂度是 O(n)**。最坏情况下，要排序的数据刚好是倒序排列的，所以要进行 n 次冒泡操作，所以**最坏情况时间复杂度为 O(n ^ 2)**。

###### 平均时间复杂度就是加权平均时间复杂度

1. 有序度（默认从小到大为有序）
   有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：`有序元素对：a[i] <= a[j]，如果 i < j。`比如，'2, 4, 3, 1, 5, 6'这组数据的有序度为 11， 因其有序元素对为 11 个，分别是：(2, 4), (2, 3), (2, 5), (2, 6), (4, 5), (4, 6), (3, 5), (3, 6), (1, 5), (1, 6), (5, 6)。

1.1 满有序度
对于一个倒序排列的数组，有序度是 0；对于一个完全有序的数组，有序度就是 n\*(n-1)/2，就是 15。把这种完全有序的数组的有序度叫作满有序度。

1.2 逆序度
定于与有序度相反，逆序元素对：`a[i] > a[j]，如果i < j。`

逆序度 = 满有序度 - 有序度，排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

冒泡排序过程的有序度变化，如[示意图](/MindMap/Geek/10.冒泡排序过程的有序度.jpg)。

冒泡排序包含 2 个操作原子：比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是 n\*(n-1)/2 - 初始有序度。

对于包含 n 个数据的数组进行冒泡排序，最坏情况下，初始状态有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换，取个中间值 n\*(n-1)/4。

#### 3. 插入排序(Insertion Sort)

首先，将数组中数据分成 2 个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一致有序。重复这个过程，直到未排序区间中元素为空，算法结束，[如果所示](/MindMap/Geek/10.插入排序示意图.jpg)。

对于一个给定的初始序列，移动操作的次数是固定的，就等于有序度。[示意图](/MindMap/Geek/10.插入排序的移动元素个数示意图.jpg)

```java
// 插入排序， a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
    if(n <= 1) return;

    for(int i = 1; i < n; ++i) {
        int value = a[i];
        int j = i - 1;
        // 查找插入的位置
        for (; j >= 0; --j) {
            if(a[j] > value) {
                a[j+1] = a[j]; // 数据移动
            } else {
                break;
            }
        }
        a[j+1] = value; // 插入数据
    }
}
```

##### 1. 插入排序是原地排序算法吗？

是。插入排序算法的运行不需要额外的存储空间，空间复杂度为 O(1)，所以，这是一个原地排序算法。

##### 2. 插入排序算法是稳定的排序算法吗？

是。

##### 3. 插入排序的时间复杂度是多少？

最好时间复杂度是 O(n)，最坏情况时间复杂度是 O(n ^ 2)，平均时间复杂度是 O(n ^ 2)。

#### 4. 选择排序(Selection Sort)

[原理示意图](/MindMap/Geek/10.选择排序原理示意图.jpg)，选择排序空间复杂度是 O(1)，是一种原地排序算法。最好、最坏、平均情况时间复杂度都为 O(n ^ 2)。选择排序算法一种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

#### 5. 总结

|          |  原地排序 | 是否稳定 | 最好、最坏、平均情况时间复杂度 |
| :------: | :-------: | :------: | :----------------------------: |
| 冒泡排序 |    ✅     |    ✅    |      O(n), O(n^2), O(n^2)      |
| 插入排序 |    ✅     |    ✅    |      O(n), O(n^2), O(n^2)      |
| 选择排序 |    ✅     |    ❎    |     O(n^2), O(n^2), O(n^2)     |
