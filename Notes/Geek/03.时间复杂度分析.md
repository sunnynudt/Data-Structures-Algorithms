### 时间复杂度分析

#### 1. 只关注循环执行次数最多的一段代码

大 O 这种复杂度表示方法只是表示一种*变化趋势*。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的`n`量级，就要整段要分析代码的时间复杂度。

```c
int cal(int n) {
    int sum = 0;
    int i = 1;
    for(; i <= n; ++i) {
        sum = sum + i;
    }
    return sum;
}
```

其中第 2、3 行代码  都是常量级的执行时间，与`n`的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码， 所以这块代码要重点分析。如前文所述，这两行代码被执行了`n`次，所以总的时间复杂度就是`O(n)`。

#### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

```c
int cal(int n) {
    int sum_1 = 0;
    int p = 1;
    for(; p < 100; ++p) {
        sum_1 = sum_1 + p;
    }

    int sum_2 = 0;
    int q = 1;
    for(; q < n; ++q) {
        sum_2 = sum_2 + q;
    }

    int sum_3 = 0;
    int i = 1;
    int j = 1;
    for(; i <= n; ++i) {
        j = 1;
        for(; j <= n; ++j) {
            sum_3 = sum_3 + i * j;
        }
    }
    return sum_1 + sum_2 + sum_3;
}
```

这段代码分为 3 部分，分别是求`sum1、sum2、sum3`。我们可以分别分析每一部分的复杂度，然后  把它们放在一块，再取一个量级最大的作为整段代码的复杂度。  
第一段代码循环执行了 100 次，所以是一个常量的执行时间，跟`n`的规模无关。  
这里要强调一下，即便这段代码执行了 10000 次、100000 次，只要是一个已知的数，跟`n`无关，照样也是常量级的执行时间。当`n`无限大的时候，就可以忽略。尽管对代码的执行时间会有很大的影响，但是回到时间复杂度的概念来说，它表示的是一个`算法执行效率与数据规模增长的变化趋势`，所以尽管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。  
以此类推，第 2 段和第 3 段代码的时间复杂度分别是`O(n)和O(n^2)`。  
综合这段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为`O(n^2)`。也就是说`总的时间复杂度就等于量级最大的那段代码的时间复杂度`，我们将这个规律抽象成公式就是：
如果`T1(n) = O(f(n)), T2(n) = O(g(n))`；那么`T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))`。

#### 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

如果`T1(n) = O(f(n)), T2(n) = O(g(n))`；那么`T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))`。
也就是说，假设`T1(n) = O(n), T2(n) = O(n^2)`，则`T1(n) * T2(n) = O(n^3)`。落实到具体的代码上，可以把乘法法则看成`嵌套循环`。

```c
int cal(int n) {
    int ret = 0;
    int i = 1;
    for(; i < n; ++i) {
        ret = ret + f(i);
    }

    int f(int n) {
        int sum = 0;
        int i = 1;
        for(; i < n; ++i) {
            sum = sum + i;
        }
        return sum;
    }
}
```

我们单独看`cal()`函数。假设`f()`只是一个普通的操作，那第 4~6 行的复杂度就是，`T1(n) = O(n)`。但`f()`函数本身就不是一个简单的操作，它的时间复杂度是`T2(n) = O(n)`，所以，整个`cal()`函数的时间复杂度就是，`T(n) = T1(n) * T2(n) = O(n*n) = O(n^2)`。
