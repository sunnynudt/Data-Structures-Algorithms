### 09. 递归

#### 1. 如何理解递归(Recursion)

举例：电影院坐在第几排，问前面的人，依次问到第一排，然后再依次把数字传回来。

这是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。

`f(n) = f(n-1) + 1 其中, f(1) = 1`。

改成递归公式：

```c
int f(int n) {
    if (n == 1) {
        return 1;
    }
    return f(n-1) + 1;
}
```

#### 2. 递归需要满足的 3 个条件

只要同时满足一下 3 个条件，就可以用递归来解决。

1. 一个问题的解可以分解为几个子问题的解。

    子问题是数据规模更小的问题。比如电影院的例子，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。

2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。

    求解“自己在哪一排”，和前面一排人求解“自己在哪一排”的思路是一样的。

3. 存在递归终止条件。

    把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。比如电影院的例子，第一排的人不需要再问其他人，就知道自己是第一排，f(1) = 1，这就是递归的终止条件。

#### 3. 如何编写递归代码

写递归代码最关键的是写出递推公式，找到终止条件。

假如有 n 个台阶，每次可以跨 1 个或 2 个台阶，请问走这 n 个台阶有多少种走法？

实际上，可以根据第一步的走法把所有的走法分成 2 类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法加上先走 2 阶后，n-2 个台阶的走法。

`f(n) = f(n-1) + f(n-2)`

再看终止条件，当有一个台阶时，不需要再递归了，只有一种走法，所以 f(1) = 1。这个终止条件不够，可以用 n=2 和 n=3 试验一下。

n=2，f(2) = f(1) + f(0)。如果终止条件只有一个 f(1) = 1，那么 f(2)就无法求解。所以除了 f(1)=1 这个终止条件外，还要有 f(0)=1，表示走 0 个台阶有 1 种走法，不过这样不符合正常的思维逻辑。所以，可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有 2 种走法。

所以，递归的终止条件是 f(1)=1，f(2)=2。可以再用 n=3，n=4 验证一下。

把递归终止条件和递推公式放在一起：

```c
f(1) = 1;
f(2) = 2;
f(n) = f(n-1) + f(n-2);
```

转换成代码：

```c
int f(int n) {
    if (n == 1) {
        return 1;
    }
    if(n == 2) {
        return 2;
    }
    return f(n - 1) + f(n - 2);
}
```

所以，写递归代码的关键就是**找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码**。

#### 4. 正确的思维方式 ✅

计算机擅长做重复的事情，所以递推正合它胃口。而人脑更喜欢平铺直叙的思维方式。当我们看到递归时，总想要把递推平铺展开，脑海中就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步是怎么执行的，这样就很容易被绕进去。

对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个**思维误区**。很多时候，自己理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。正确的思维方式应如下。

💯 如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉细节，理解就简单多了。

因此，**编写递归代码的关键是，只要遇到递推，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤**。

#### 5. 递归代码要警惕堆栈溢出

函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

如何避免出现堆栈溢出呢？可以通过在代码中限制递归调用的最大深度方式来解决。递归调用超过一定深度（比如 1000）之后，就不再继续往下递归了。但是这种方法不是很实用。

#### 6. 递归代码要警惕重复计算

为了避免重复计算，可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k)时，先看下是否已经求解过。如果是，则直接从散列表中取值返回，这样就可以避免重复计算。

```javascript
public int f(int n) {
    if(n == 1) return 1;
    if(n == 2) return 2;

    // hasSolvedList 可以理解成一个Map，key是n，value是f(n)
    if(hasSolvedList.containsKey(n)) {
        return hasSolvedList.get(n);
    }

    int ret = f(n - 1) + f(n - 2);
    hasSolvedList.put(n, ret);
    return ret;
}
```
