### 排序

排序算法可以分为内部排序和外部排序。

内部排序是数据记录在内存中进行排序。

外部排序是因为排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

常见的内部排序算法有：冒泡排序、插入排序、选择排序、快速排序、归并排序、希尔排序、堆排序、基数排序等。

| 排序算法 | 平均时间复杂度 | 最好情况时间复杂度 | 最坏情况时间复杂度 | 空间复杂度 | 排序方式  | 稳定性 |
| :------: | :------------: | :----------------: | :----------------: | :--------: | :-------: | :----: |
| 冒泡排序 |     O(n^2)     |        O(n)        |       O(n^2)       |    O(1)    | In-place  |  稳定  |
| 插入排序 |     O(n^2)     |        O(n)        |       O(n^2)       |    O(1)    | In-place  |  稳定  |
| 选择排序 |     O(n^2)     |       O(n^2)       |       O(n^2)       |    O(1)    | In-place  | 不稳定 |
| 快速排序 |    O(nlogn)    |      O(nlogn)      |       O(n^2)       |  O(logn)   | In-place  | 不稳定 |
|  堆排序  |    O(nlogn)    |      O(nlogn)      |      O(nlogn)      |    O(1)    | In-place  | 不稳定 |
| 归并排序 |    O(nlogn)    |      O(nlogn)      |      O(nlogn)      |    O(n)    | Out-place |  稳定  |
| 希尔排序 |    O(nlogn)    |     O(nlog^2n)     |     O(nlog^2n)     |    O(1)    | In-place  | 不稳定 |
|  桶排序  |    O(n + k)    |      O(n + k)      |       O(n^2)       |  O(n + k)  | Out-place |  稳定  |
| 计数排序 |    O(n + k)    |      O(n + k)      |      O(n + k)      |    O(k)    | Out-place |  稳定  |
| 基数排序 |    O(n × k)    |      O(n × k)      |      O(n × k)      |  O(n + k)  | Out-place |  稳定  |

线性排序：时间复杂度时线性的，比如桶排序、计数排序和基数排序的时间复杂度是`O(n)`。之所以能做到线性的时间复杂度，主要原因是这三个算法是非基于比较的排序的算法，都不涉及元素之间的比较操作。

#### 如何分析一个排序算法？

1. 排序算法的执行效率

   - 最好情况、最坏情况、平均情况时间复杂度。
   - 时间复杂度的系数、常数和低阶。
   - 比较次数和交换（或移动）次数。

2. 排序算法的内存消耗

   - 针对排序算法的空间复杂度，引入一个新概念：原地排序(Sorted in place)。**原地排序算法，就是特指空间复杂度是 O(1)的排序算法**。

3. 排序算法的稳定性

   - 针对排序算法，有一个重要的度量指标，稳定性，就是说，如果待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变。

_Tips: 思考题：插入排序和冒泡排序的时间复杂度都是 O(n^2)，在实际的软件开发中，为什么大家更倾向于使用插入排序算法而不是冒泡排序算法呢？_

#### Content

1. [冒泡排序](/Notes/Sort/BubbleSort.md)
2. [插入排序](/Notes/Sort/InsertionSort.md)
3. [选择排序](/Notes/Sort/SelectionSort.md)
4. [**归并排序**](/Notes/Sort/MergeSort.md)
5. [**快速排序**](/Notes/Sort/QuickSort.md)
6. [线性排序：桶排序、计数排序、基数排序](/Notes/Sort/LinearSort.md)

#### 排序优化

|   类型   |      时间复杂度       | 是否稳定排序 | 是否原地排序 |
| :------: | :-------------------: | :----------: | :----------: |
| 冒泡排序 |        O(n^2)         |      ✅      |      ✅      |
| 插入排序 |        O(n^2)         |      ✅      |      ✅      |
| 选择排序 |        O(n^2)         |      ❌      |      ✅      |
| 快速排序 |       O(nlogn)        |      ❌      |      ✅      |
| 归并排序 |       O(nlogn)        |      ✅      |      ❌      |
| 计数排序 | O(n + k)(k: 数据范围) |      ✅      |      ❌      |
|  桶排序  |         O(n)          |      ✅      |      ❌      |
| 基数排序 |    O(dn)(n: 维度)     |      ✅      |      ❌      |

线性排序算法时间复杂度比较低，但是使用场景比较特殊。
如果对小规模数据进行排序，可以选择时间复杂度为 O(n^2)的算法。
如果对大规模数据进行排序，时间复杂度为 O(nlogn)的算法更加高效。

##### 快速排序优化

快速排序在最坏情况下的时间复杂度是 O(n^2)，比如数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，此时快排的时间复杂度就退化为 O(n^2)。实际上，这种 O(n^2)时间复杂度出现的主要原因还是因为我们的分区点选的不够合理。

最理想的分区点是：被分区点分开的两个分区中，数据的数量都差不多。

优化方案：1. 三数取中法；2. 随机法。
