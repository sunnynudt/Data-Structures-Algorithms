### 冒泡排序(Bubble Sort)

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它们俩互换。一次冒泡会至少让一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

```js
  const bubbleSort = arr => {
    const len = arr.length
    if (len <= 1) {
      return arr
    }
    for (let i = 0; i < len, i++) {
      // 提前退出冒泡循环的标志位
      let flag = false
      for (int j = 0; j < len - i - 1, j++) {
        if (arr[j] > arr[j + 1]) { // 交换
          let tmp = arr[j]
          arr[j] = arr[j + 1]
          arr[j + 1] = tmp
          flag = true // 表示有数据交换
        }
      }
      if (!flag) {
        break
      }
    }
    return arr
  }
```

1. 冒泡排序是原地排序算法。

   冒泡过程只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1)，所以是原地排序算法。

2. 冒泡排序是稳定的排序算法。

   冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证算法的稳定性，当相邻两个元素大小相等时，不做交换，这样，相同大小的数据在排序前后不会改变顺序，所以冒泡是稳定的排序算法。

3. 冒泡排序的时间复杂度是多少？

   如果数据是有序的，只需要进行一次冒泡排序，所以最好情况时间复杂度是 O(n)；如果数据是倒序的，需要进行 n 次冒泡操作，所以最坏时间复杂度是 O(n^2)；利用`逆序度 = 满有序度 - 有序度`，冒泡包含两个操作原子，比较和交换，每交换一次，有序度就加 1，交换次数即为逆序度，从而可以粗略的推导出平均情况下的时间复杂度也是 O(n^2)。
