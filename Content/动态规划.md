### 动态规划（Dynamic Programming）

动态规划比较适合用来解决最优问题，比如求最大值、最小值，它可以非常显著地降低时间复杂度，提高代码的执行效率。

#### 1. 理解动态规划

##### 1. 参考文献

- [通过金矿模型介绍动态规划](https://www.cnblogs.com/SDJL/archive/2008/08/22/1274312.html)
- [知乎：如何理解动态规划](https://www.zhihu.com/question/39948290)
- [知乎：什么是动态规划？动态规划的意义是什么？](https://www.zhihu.com/question/23995189/answer/56259510)
- [公众号：看动画轻松理解「递归」与「动态规划」](http://www.cxyxiaowu.com/posts/ccd7f89d/)

##### 2. 思考动态规划（以金矿模型为例）

_子问题_：国王需要根据两个大臣以及第 9 座金矿（最后一个金矿，从 0 开始排序）的信息才能判断出最多能够开采出多少金子。为了解决自己面临的问题，他需要给别人制造另外 2 个问题，这两个问题就是子问题。

1. 思考动态规划的第一点：**最优子结构**

国王相信这要两个大臣能够给出正确的答案（对于考虑能够开采出的金子数，最多的也就是最优的同时也就是正确的），加上自己的判断，就可以得出最终的正确的答案。我们把这种子问题最优时母问题通过优化选择后一定最优的情况叫做“最优子结构”。

2. 思考动态规划的第二点：**子问题重叠**

所有人面对的都是同样的问题，即给你一定数量的人，给你一定数量的金矿，让你求出能够开采出的最多金子数。把这种母问题和子问题本质上是同一个问题的情况称为“子问题重叠”。然而问题中出现的不同点往往就是被子问题之间传递的参数，比如这里的人数和金矿数。

3. 思考动态规划的第三点：**边界**

把这种子问题在一定时候就不再需要提出子问题的情况叫做边界，没有边界就会出现死循环。

4. 思考动态规划的第四点：**子问题独立**

当国王的两位大臣在思考他们自己的问题时他们是不会去关心对方是如何计算怎么样开采金矿的，因为他们知道，国王只会选择两个人中的一个作为最后方案，另一个人的方案并不会得到实施，因此一个人的决定对另一个人的决定是没有影响的。我们把这种一个母问题在对子问题选择时，当前被选择的子问题两两互不影响的情况叫做“子问题独立”。

5. 思考动态规划的第五点：**做备忘录**

当我们遇到相同的问题时，可以问同一个人。讲的通俗一点，我们可以把问题的解放在同一个变量中，如果再次遇到这个问题就直接从变量中获取答案，因此每一个问题仅会计算一遍，如果不做备忘录，动态规划就没有任何优势可言了。

6. 思考动态规划的第六点：**时间分析**

非正式的，我们可以很容易得到动态规划所需时间。如果有 `questionCount` 个相同的子问题，而每个子问题需要面对 `chooseCount` 种选择，我们所需时间就为 `questionCount * chooseCount` 个常数。在金矿模型中，子问题最多大概有 `people * n` 个（其中 people 是用于开采金矿的总人数，n 是金矿的总数），因此 `questionCount = people * n`，就像国王采用左右两位部下的结果一样，每个问题面对两个选择，因此 `chooseCount = 2`，所以程序运行时间为 `T = O(questionCount * chooseCount) = O(people * n)`，实际上所需的时间小于这个值。

##### 3. 动态规划的思考角度（以金矿模型为例）

如果一个解决问题的方法满足上述 6 个思考点中的前 4 个，那么这个方法就属于动态规划。而在思考动态规划方法时，后 2 点同样也需要考虑。

面对问题要寻找动态规划的方法，首先要清楚一点，**动态规划不是算法，它是一种方法**，是在一件事情发生的过程中寻找最优值得方法，因此，我们需要对这件事情所发生的过程进行考虑。

通常，从过程的**最后一步**开始考虑，而不是先考虑过程的开始。过程的开始，也就是考虑的最后一步，就是**边界**。

因此，在遇到一个方法想用动态规划去解决时，不妨先思考一下这个过程是怎么样的，然后考虑过程的最后一步是如何选择的，通常我们需要自己去构造一个过程。

##### 4. 遇到问题如何用动态规划去解决？

根据上述分析，可以采取以下步骤去考虑：

1.  构造问题所对应的过程。
2.  思考过程的最后一个步骤。
3.  找到最后一步的子问题，确保符合“子问题重叠”，把子问题中的不相同的地方设置为参数。
4.  使得子问题符合“最优子结构”。
5.  找到边界，考虑边界的各种处理方式。
6.  确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。
7.  考虑如何做备忘录。
8.  分析所需时间是否满足要求。
9.  写出转移方程式。

##### 5. [代码示例：动态规划之金矿模型](/Algo/DP-GoldMine.js)

##### 6. 动态规划与分治策略

相同：将原问题分解成若干个规模较小的子问题，然后递归的求解这些子问题，最后合并子问题的解得到原问题的解。

区别：动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间。所以，能用动态规划解决的问题，分治策略也可以，只是运行时间更长一点。分治策略一般用来解决子问题相互独立的问题，称之为标准分治；而动态规划用来解决子问题重叠的问题。

简而言之，动态规划概念的关键点：

- 动态规划试图只解决每个子问题一次。
- 一旦某个给定子问题的解已经算出，将其记忆化存储，以便于下次需要同一个子问题解时直接查表。

##### 7. 爬台阶：递归和动态规划

1. 使用递归实现，时间复杂度 O(2^n)。

```javascript
function recursion(n) {
  if (n < 1) {
    return 0
  }
  if (n == 1) {
    return 1
  }
  if (n == 2) {
    return 2
  }
  return recursion(n - 1) + recursion(n - 2)
}
```

2. 使用动态规划实现，时间复杂度 O(n)，空间复杂度 O(1)

```javascript
function dynamicProgramming(n) {
  if (n < 1) {
    return 0
  }
  if (n == 1) {
    return 1
  }
  if (n == 2) {
    return 2
  }
  // a保存倒数第二个子状态数据，b保存倒数第一个子状态数据，temp保存当前状态的数据
  let a = 1
  let b = 2
  let temp = a + b
  for (let i = 3; i <= n; i++) {
    temp = a + b
    a = b
    b = temp
  }
  return temp
}
```

#### 2. ["一个模型三个特征"理论讲解](https://time.geekbang.org/column/article/75702)

什么样的问题适合用动态规划来解决？换句话说，动态规划能解决的问题有什么规律可循？总结为“一个模型三个特征”。

一个模型，指的是动态规划适合解决的问题的模型，可以定义为“多阶段决策最优解模型”。

一般用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应一组状态，然后我们寻找一组决策序列，经过这一组决策序列，能够产生最终期望求解的最优值。

##### 1. 三个特征

1. 最优子结构
   最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

2. 无后效性
   无后效性有两层含义，一是在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步步推导出来的。二是某个阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。

3. 重复子问题
   不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

##### 2. 实例剖析：矩阵最短路径

以矩阵最短路径为例。

|          |     |     |        |
| -------- | --- | --- | ------ |
| 1(start) | 3   | 5   | 9      |
| 2        | 1   | 3   | 4      |
| 5        | 2   | 6   | 7      |
| 6        | 8   | 4   | 3(end) |

假设`n*n`矩阵`w[n][n]`，存储的都是正整数，起始位置是左上角，终止位置在右下角，每次移动只能向右或向下移动一位，每条路径经过的数字加起来看作路径的长度，那从左上角移动到右下角的最短路径长度是多少呢？

从`(0, 0)`走到`(n-1, n-1)`，总共要走`2*(n-1)`步，也就对应着`2*(n-1)`个阶段，每个阶段都有向右走或向下走两种决策，并且每个阶段都会对应以一个状态集合。

定义状态的时候，把从起始位置`(0, 0)`到`(i, j)`的最小路径，记作`min_dist(i, j)`。因为只能右移或下移，所以只能从`(i, j - 1)`或`(i - 1, j)`两个位置到达`(i, j)`。也就是说，到达`(i, j)`的最短路径要么经过`(i, j - 1)`，要么经过`(i - 1, j)`，而且到达`(i, j)`的最短路径肯定包含到达这两个位置的最短路径之一。所以，`min_dist(i, j)`可以通过`min_dist(i, j - 1)`和`min_dist(i - 1, j)`两个状态推导出来，此问题符合“最优子结构”。

`min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i - 1, j))`

##### 3. 两种动态规划解题思路总结

以矩阵最短路径为例。

1. **状态转移表法**

先画出一个状态表。状态表一般都是二维的，可以想象成二维数组。其中每个状态包含三个变量，行、列、数组值。根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，将这个递推填表的过程，翻译成代码，就是动态规划代码了。

尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那么对应的状态表可能是高维的，比如三维四维。这个时候就不适合用状态转移表法来解决了。

```java
// 回溯算法
private int minDist = Integer.MAX_VALUE; // 全局变量或成员变量
// 调用方式：minDistBacktracing(0,0,0,w,n)
public void minDistBT(int i, int j, int dist, int[][] w, int n) {
    //到达了n-1，n-1这个位置
    if (i == n && j == n) {
        if (dist < minDist) {
            minDist = dist;
        }
        return
    }

    if (i < n) { // 往下走，更新 i = i + 1, j = j
        minDistBT(i + 1, j, dist + w[i][j], w, n)
    }

    if (j < n) { // 往右走，更新 i = i, j = j + 1
        minDistBT(i, j + 1, dist + w[i][j], w, n)
    }
}
```

```java
// 动态规划-状态转移表法
public int minDistDP(int[][] matrix, int n) {
    int[][] states = new int[n][n];
    int sum = 0;
    for (int j = 0; j < n; ++j) {
        sum += matrix[0][j];
        states[0][j] = sum;
    }
    sum = 0;
    for (int i = 0; i < n; ++i) {
        sum += matrix[i][0];
        states[i][0] = sum;
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 1; j < n; ++j) {
            states[i][j] = matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]);
        }
    }
    return states[n-1][n-1];
}
```

2. **状态转移方程法**

状态转移方程法有点类似于递归的解题思路。我们需要分析某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，就是所谓的状态转移方程。有个状态转移方程，代码实现就容易许多。一般有两种代码实现方法，一种是**递归加“备忘录”**，另一种是**迭代递推**。

状态转移方程：`min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))`

**状态转移方程是解决动态规划的关键。**

```java
// 递归加“备忘录”的形式实现上述的状态转移方程
private int[][] matrix = {{1, 3, 5, 9}, {2, 1, ,3, 4}, {5, 2, 6, 7}, {6, 8, 3, 4}};
private int n = 4;
private int[][] mem = new int[4][4];
public int minDist(int i, int j) { // 调用minDist(n-1, n-1)
    if (i == 0 && j == 0) {
        return matrix[0][0];
    }
    if (mem[i][j] > 0) {
        return mem[i][j];
    }
    if (j-1 >= 0) {
        minLeft = minDist(i, j-1);
    }
    int minUp = Integer.MAX_VALUE;
    if (i-1 >= 0) {
        minUp = minDist(i-1, j);
    }
    int currMinDist = matrix[i][j] + Math.min(minLeft, minUp);
    mem[i][j] = currMinDist;
    return currMinDist;
}
```
