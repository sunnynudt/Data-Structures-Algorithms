### 插入排序(Insertion Sort)

实现思想：将数组中的数据分成两个区，**已排序区间**和**未排序区间**，初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的**核心思想**是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

插入排序包含两种操作：元素的比较和元素的移动。当需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点后，还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

```js
const insertionSort = arr => {
  const len = arr.length
  if (len <= 1) {
    return arr
  }
  for (let i = 1; i < len; i++) {
    // 记录要插入的数据
    let currentValue = arr[i]
    // 从已排序的数组最右边开始比较
    let prevIndex = i - 1
    while (prevIndex >= 0 && arr[prevIndex] > currentValue) {
      arr[prevIndex + 1] = arr[prevIndex]
      prevIndex--
    }
    arr[prevIndex + 1] = currentValue // 插入数据
  }

  return arr
}
```

1. 插入排序是原地排序算法。

   插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，即为原地排序算法。

2. 插入排序是稳定的排序算法。

   在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序算法是稳定的排序算法。

3. 插入排序的时间复杂度是多少？

   如果数据是有序的，并不需要搬移数据，只是从头到尾遍历已经有序的数据，最好时间复杂度是 O(n)；如果数组是倒序的，需要移动大量的数据，最坏情况时间复杂度是 O(n^2)；平均时间复杂度为 O(n^2)。
