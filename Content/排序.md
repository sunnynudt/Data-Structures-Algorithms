### 排序

#### 线性排序

时间复杂度时线性的，比如桶排序、计数排序和基数排序的时间复杂度是`O(n)`。之所以能做到线性的时间复杂度，主要原因是这三个算法是非基于比较的排序的算法，都不涉及元素之间的比较操作。

##### 1. 桶排序(Bucket sort)

核心思想：将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排序完成后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

1. 时间复杂度`O(n)`
   假设要排序的数据有 n 个，把它们均匀的划分到 m 个桶里，每个桶里有`k=n/m`个元素。每个桶的内部使用快速排序，时间复杂度为`O(k*logk)`。m 个桶排序的时间复杂度就是`O(m*k*logk)`，因为`k=n/m`，所以整个桶排序的时间复杂度就是`O(n*log(n/m))`。当桶的个数 m 接近数据个数 n 时，`log(n/m)`就是一个非常小的常量，此时桶排序的时间复杂度接近`O(n)`。

2. 桶排序的不足
   桶排序实际上对要排序数据的要求是非常苛刻的。

   首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完后，桶与桶之间数据就不需要再进行排序。

   其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，若所有数据都被划分到一个桶里，那就退化为`O(nlogn)`的排序算法了。

   3. 桶排序适用场景：外部排序

   所谓外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。案例：有 10GB 的订单数据，希望按照订单金额（假设为正整数）进行排序，但是内存只有几百 M，没办法一次性把 10GB 数据都加载到内存中。
