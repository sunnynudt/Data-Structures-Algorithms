### 排序

#### 如何分析一个排序算法？

1. 排序算法的执行效率

   - 最好情况、最坏情况、平均情况时间复杂度。
   - 时间复杂度的系数、常数和低阶。
   - 比较次数和交换（或移动）次数。

2. 排序算法的内存消耗

   - 针对排序算法的空间复杂度，引入一个新概念：原地排序(Sorted in place)。原地排序算法，就是特指空间复杂度是 O(1)的排序算法。

3. 排序算法的稳定性
   - 针对排序算法，有一个重要的度量指标，稳定性，就是说，如果待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变。

#### 冒泡、插入、选择排序：O(n^2)

_Tips: 思考题：插入排序和冒泡排序的时间复杂度都是 O(n^2)，在实际的软件开发中，为什么大家更倾向于使用插入排序算法而不是冒泡排序算法呢？_

#### 线性排序

时间复杂度时线性的，比如桶排序、计数排序和基数排序的时间复杂度是`O(n)`。之所以能做到线性的时间复杂度，主要原因是这三个算法是非基于比较的排序的算法，都不涉及元素之间的比较操作。

##### 1. 桶排序(Bucket sort)

核心思想：将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排序完成后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

1. 时间复杂度`O(n)`
   假设要排序的数据有 n 个，把它们均匀的划分到 m 个桶里，每个桶里有`k=n/m`个元素。每个桶的内部使用快速排序，时间复杂度为`O(k*logk)`。m 个桶排序的时间复杂度就是`O(m*k*logk)`，因为`k=n/m`，所以整个桶排序的时间复杂度就是`O(n*log(n/m))`。当桶的个数 m 接近数据个数 n 时，`log(n/m)`就是一个非常小的常量，此时桶排序的时间复杂度接近`O(n)`。

2. 桶排序的不足
   桶排序实际上对要排序数据的要求是非常苛刻的。

   首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完后，桶与桶之间数据就不需要再进行排序。

   其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，若所有数据都被划分到一个桶里，那就退化为`O(nlogn)`的排序算法了。

   3. 桶排序适用场景：外部排序

   所谓外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。案例：有 10GB 的订单数据，希望按照订单金额（假设为正整数）进行排序，但是内存只有几百 M，没办法一次性把 10GB 数据都加载到内存中。

##### 2. 计数排序(Counting sort)

计数排序可以看作是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶，每个桶内的数据值都是**相同**的，省掉了桶内排序的时间。案例：高考查分系统。

特点：计数排序只能用在数据范围不大的场景中，如果数据范围 k 要比排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

##### 3. 基数排序(Radix sort)

特点：基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围都不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n)了。

##### 4. 小结

桶排序和计数排序的排序思想是非常相似的，都是针对**范围不大**的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成**高低位**，位之间有递进关系。比较两个数，只需要比较高位，高位相同的再比较低位，且每一位的数据范围都不能太大，因为基数排序算法需要借助桶排序或计数排序来完成每一个位的排序工作。

#### 排序优化

|   类型   |      时间复杂度       | 是否稳定排序 | 是否原地排序 |
| :------: | :-------------------: | :----------: | :----------: |
| 冒泡排序 |        O(n^2)         |      ✅      |      ✅      |
| 插入排序 |        O(n^2)         |      ✅      |      ✅      |
| 选择排序 |        O(n^2)         |      ❎      |      ✅      |
| 快速排序 |       O(nlogn)        |      ❎      |      ✅      |
| 归并排序 |       O(nlogn)        |      ✅      |      ❎      |
| 计数排序 | O(n + k)(k: 数据范围) |      ✅      |      ❎      |
|  桶排序  |         O(n)          |      ✅      |      ❎      |
| 基数排序 |    O(dn)(n: 维度)     |      ✅      |      ❎      |

线性排序算法时间复杂度比较低，但是使用场景比较特殊。
如果对小规模数据进行排序，可以选择时间复杂度为 O(n^2)的算法。
如果对大规模数据进行排序，时间复杂度为 O(nlogn)的算法更加高效。

##### 快速排序优化

快速排序在最坏情况下的时间复杂度是 O(n^2)，比如数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，此时快排的时间复杂度就退化为 O(n^2)。实际上，这种 O(n^2)时间复杂度出现的主要原因还是因为我们的分区点选的不够合理。

最理想的分区点是：被分区点分开的两个分区中，数据的数量都差不多。

优化方案：1. 三数取中法；2. 随机法。
