### 排序

排序算法可以分为内部排序和外部排序。

内部排序是数据记录在内存中进行排序。

外部排序是因为排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

常见的内部排序算法有：冒泡排序、插入排序、选择排序、快速排序、归并排序、希尔排序、堆排序、基数排序等。

| 排序算法 | 平均时间复杂度 | 最好情况时间复杂度 | 最坏情况时间复杂度 | 空间复杂度 | 排序方式  | 稳定性 |
| :------: | :------------: | :----------------: | :----------------: | :--------: | :-------: | :----: |
| 冒泡排序 |     O(n^2)     |        O(n)        |       O(n^2)       |    O(1)    | In-place  |  稳定  |
| 插入排序 |     O(n^2)     |        O(n)        |       O(n^2)       |    O(1)    | In-place  |  稳定  |
| 选择排序 |     O(n^2)     |       O(n^2)       |       O(n^2)       |    O(1)    | In-place  | 不稳定 |
| 快速排序 |    O(nlogn)    |      O(nlogn)      |       O(n^2)       |  O(logn)   | In-place  | 不稳定 |
|  堆排序  |    O(nlogn)    |      O(nlogn)      |      O(nlogn)      |    O(1)    | In-place  | 不稳定 |
| 归并排序 |    O(nlogn)    |      O(nlogn)      |      O(nlogn)      |    O(n)    | Out-place |  稳定  |
| 希尔排序 |    O(nlogn)    |     O(nlog^2n)     |     O(nlog^2n)     |    O(1)    | In-place  | 不稳定 |
|  桶排序  |    O(n + k)    |      O(n + k)      |       O(n^2)       |  O(n + k)  | Out-place |  稳定  |
| 计数排序 |    O(n + k)    |      O(n + k)      |      O(n + k)      |    O(k)    | Out-place |  稳定  |
| 基数排序 |    O(n × k)    |      O(n × k)      |      O(n × k)      |  O(n + k)  | Out-place |  稳定  |

#### 如何分析一个排序算法？

1. 排序算法的执行效率

   - 最好情况、最坏情况、平均情况时间复杂度。
   - 时间复杂度的系数、常数和低阶。
   - 比较次数和交换（或移动）次数。

2. 排序算法的内存消耗

   - 针对排序算法的空间复杂度，引入一个新概念：原地排序(Sorted in place)。**原地排序算法，就是特指空间复杂度是 O(1)的排序算法**。

3. 排序算法的稳定性
   - 针对排序算法，有一个重要的度量指标，稳定性，就是说，如果待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变。

#### 冒泡排序(Bubble Sort)

_Tips: 思考题：插入排序和冒泡排序的时间复杂度都是 O(n^2)，在实际的软件开发中，为什么大家更倾向于使用插入排序算法而不是冒泡排序算法呢？_

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它们俩互换。一次冒泡会至少让一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

```js
  const bubbleSort = arr => {
    const len = arr.length
    if (len <= 1) {
      return arr
    }
    for (let i = 0; i < len, i++) {
      // 提前退出冒泡循环的标志位
      let flag = false
      for (int j = 0; j < len - i - 1, j++) {
        if (arr[j] > arr[j + 1]) { // 交换
          let tmp = arr[j]
          arr[j] = arr[j + 1]
          arr[j + 1] = tmp
          flag = true // 表示有数据交换
        }
      }
      if (!flag) {
        break
      }
    }
    return arr
  }
```

1. 冒泡排序是原地排序算法。

   冒泡过程只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1)，所以是原地排序算法。

2. 冒泡排序是稳定的排序算法。

   冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证算法的稳定性，当相邻两个元素大小相等时，不做交换，这样，相同大小的数据在排序前后不会改变顺序，所以冒泡是稳定的排序算法。

3. 冒泡排序的时间复杂度是多少？

   如果数据是有序的，只需要进行一次冒泡排序，所以最好情况时间复杂度是 O(n)；如果数据是倒序的，需要进行 n 次冒泡操作，所以最坏时间复杂度是 O(n^2)；利用`逆序度 = 满有序度 - 有序度`，冒泡包含两个操作原子，比较和交换，每交换一次，有序度就加 1，交换次数即为逆序度，从而可以粗略的推导出平均情况下的时间复杂度也是 O(n^2)。

#### 插入排序(Insertion Sort)

实现思想：将数组中的数据分成两个区，**已排序区间**和**未排序区间**，初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的**核心思想**是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

插入排序包含两种操作：元素的比较和元素的移动。当需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点后，还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

```js
const insertionSort = arr => {
  const len = arr.length
  if (len <= 1) {
    return arr
  }
  for (let i = 1; i < len; i++) {
    // 记录要插入的数据
    let currentValue = arr[i]
    // 从已排序的数组最右边开始比较
    let prevIndex = i - 1
    while (prevIndex >= 0 && arr[prevIndex] > currentValue) {
      arr[prevIndex + 1] = arr[prevIndex]
      prevIndex--
    }
    arr[prevIndex + 1] = currentValue // 插入数据
  }

  return arr
}
```

1. 插入排序是原地排序算法。

   插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，即为原地排序算法。

2. 插入排序是稳定的排序算法。

   在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序算法是稳定的排序算法。

3. 插入排序的时间复杂度是多少？

   如果数据是有序的，并不需要搬移数据，只是从头到尾遍历已经有序的数据，最好时间复杂度是 O(n)；如果数组是倒序的，需要移动大量的数据，最坏情况时间复杂度是 O(n^2)；平均时间复杂度为 O(n^2)。

#### 选择排序(Selection Sort)

实现思想：类似于插入排序，将数组也区分为已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

选择排序空间复杂度为 O(1)，是一种原地排序算法。其最好、最坏、平均情况时间复杂度都为 O(n^2)。

选择排序不是稳定的排序算法，因为其每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，破坏了稳定性。

```js
const selectionSort = arr => {
  const len = arr.length
  if (len <= 1) {
    return arr
  }
  // 总共需要经过 len - 1次比较
  for (let i = 0; i < len - 1; i++) {
    let min = i
    // 每轮需要比较的次数 len - i
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[min]) {
        // 记录目前能找到的最小值元素的小标
        min = j
      }
    }
    // 将找到的最小值和i位置所在的值进行交换
    if (i !== min) {
      let tmp = arr[i]
      arr[i] = arr[min]
      arr[min] = tmp
    }
  }
  return arr
}
```

#### 归并排序(Merge Sort)

核心思想：先将数组从中间分成前后两部分，然后对前后两部分分别排序，再将排序好的两部分合并在一起。

归并排序使用的是分治思想，顾名思义，就是将一个大问题分解成小问题来解决。分治算法一般都是用递归来实现的。**分治是一种解决问题的处理思想，递归是一种编程技巧**，两者并不冲突。

##### 1. 归并排序算法步骤：

已经原数组 A[p...r]，排序后的 2 个子数组分别为 A[p...q]和 A[q+1...r]。

1. 申请临时数组 tmp，大小与 A[p...r]相同。
2. 设定 2 个游标 i 和 j，A[p...q]和 A[q+1...r]的第 1 个元素。
3. 比较 A[i]和 A[j]，选择较小的元素放入数组 tmp，其对应的游标移到下一位。
4. 重复第 3 步，直到某个游标到达数组尾部，对应的数组的元素已全部存入数组 tmp。
5. 将另一个数组中的剩下的所有元素依次加入到数组 tmp 中，此时临时数组 tmp 中存储的就是两个子数组合并后的结果。
6. 将临时数组 tmp 中的数据拷贝到原数组 A[p...r]中。

```js
const merge = (left = [], right = []) => {
  let tmp = []
  while (left.length > 0 && right.length > 0) {
    if (left[0] <= right[0]) {
      tmp.push(left.shift())
    } else {
      tmp.push(right.shift())
    }
  }
  while (left.length > 0) {
    tmp.push(left.shift())
  }
  while (right.length > 0) {
    tmp.push(right.shift())
  }
  return tmp
}

const mergeSort = (arr = []) => {
  const len = arr.length
  if (len <= 1) {
    return arr
  }
  const middle = Math.floor(len / 2)
  const left = arr.slice(0, middle)
  const right = arr.slice(middle)
  return merge(mergeSort(left), mergeSort(right))
}
```

##### 2. 性能分析

1. 归并排序是稳定的排序算法。
2. 最好、最坏、平均情况时间复杂度都是 O(nlogn)。
3. 空间复杂度是 O(n)。

#### 快速排序(Quick Sort)

快排是处理大数据最快的排序算法之一。快排在平均情况下，排序 n 个数据要 O(nlogn)次比较，在最坏情况下则需要 O(n^2)次比较，但是这种情况比较少见。实际中，快排通常要比其他 O(nlogn)算法要快，因为它的内部循环(inner loop)可以在大部分的架构上很有效率的被实现出来。

> 快排的最坏运行情况是 O(n^2)，比如顺序数组的排序。但是平均时间复杂度时 O(nlogn)，且 O(nlogn)记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数组而言，快速排序总是优于归并排序。——《算法艺术与信息学竞赛》

快排也是利用分治思想，看起来像归并排序，但是思路完全不同。

核心思想：如果要排序数组中下标从 p 到 r 之间的一组数据，可选择 p 到 r 之间的任意一个数据作为 pivot(区分点)。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤后，数组 p 到 r 之间的数据就被分成了 3 个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间都是大于 pivot 的。根据分治、递归的处理思想，可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有数据都有序了。

快速排序的核心问题是基准元素的选择以及元素的移动。

##### 元素的移动

1. 挖坑法(递归)

```js
// 通过递归的方式，实现了分而治之的思想。
function quickSort(arr = [], startIndex = 0, endIndex = 0) {
  // 递归结束条件
  if (startIndex >= endIndex) {
    return arr
  }
  // 得到基准元素位置
  let pivotIndex = partition(arr, startIndex, endIndex)
  // 分治法递归数组的两部分
  quickSort(arr, startIndex, pivotIndex - 1)
  quickSort(arr, pivotIndex + 1, endIndex)
  return arr
}

// 实现元素的移动，让数组中的元素依据自身大小，分别移动到基准元素的左右两边。
function partition(arr = [], startIndex = 0, endIndex = 0) {
  // 取第一个位置的元素做基准
  let pivot = arr[startIndex]
  let left = startIndex
  let right = endIndex
  // 坑的位置，初始等于pivot的位置
  let index = startIndex
  // 大循环在左右指针重合或交错时候结束
  while (right >= left) {
    // right指针从右向左进行比较
    while (right >= left) {
      if (arr[right] < pivot) {
        arr[left] = arr[right]
        index = right
        left++
        break
      }
      right--
    }
    // left指针从左向右进行比较
    while (right >= left) {
      if (arr[left] > pivot) {
        arr[right] = arr[left]
        index = left
        right--
        break
      }
      left++
    }
  }
  arr[index] = pivot
  return index
}
```

2. 指针交换法(递归)

##### 2. 快速排序与归并排序的区别

1. 归并排序的处理是**由下到上**，先处理子问题，然后再合并。

2. 快排正好相反，处理过程是**由下到上**，先分区，然后再处理子问题。

3. 归并排序虽然是稳定的、时间复杂度为 O(nlogn)，但是它是非原地排序算法，主要是因为合并函数无法在原地执行。

4. 快排通过设计原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

##### 3. 性能分析

1. 快排是原地排序算法，空间复杂度是 O(1)。
2. 快排平均时间复杂度是 O(nlogn)，最坏时间复杂度是 O(n^2)。
3. 快排是不稳定的排序算法。

#### 线性排序

时间复杂度时线性的，比如桶排序、计数排序和基数排序的时间复杂度是`O(n)`。之所以能做到线性的时间复杂度，主要原因是这三个算法是非基于比较的排序的算法，都不涉及元素之间的比较操作。

##### 1. 桶排序(Bucket sort)

核心思想：将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排序完成后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

1. 时间复杂度`O(n)`

   假设要排序的数据有 n 个，把它们均匀的划分到 m 个桶里，每个桶里有`k=n/m`个元素。每个桶的内部使用快速排序，时间复杂度为`O(k*logk)`。m 个桶排序的时间复杂度就是`O(m*k*logk)`，因为`k=n/m`，所以整个桶排序的时间复杂度就是`O(n*log(n/m))`。当桶的个数 m 接近数据个数 n 时，`log(n/m)`就是一个非常小的常量，此时桶排序的时间复杂度接近`O(n)`。

2. 桶排序的不足

   桶排序实际上对要排序数据的要求是非常苛刻的。

   首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完后，桶与桶之间数据就不需要再进行排序。

   其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，若所有数据都被划分到一个桶里，那就退化为`O(nlogn)`的排序算法了。

3. 桶排序适用场景：外部排序

   所谓外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。案例：有 10GB 的订单数据，希望按照订单金额（假设为正整数）进行排序，但是内存只有几百 M，没办法一次性把 10GB 数据都加载到内存中。

##### 2. 计数排序(Counting sort)

计数排序可以看作是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶，每个桶内的数据值都是**相同**的，省掉了桶内排序的时间。案例：高考查分系统。

特点：计数排序只能用在数据范围不大的场景中，如果数据范围 k 要比排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

##### 3. 基数排序(Radix sort)

特点：基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围都不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n)了。

##### 4. 小结

桶排序和计数排序的排序思想是非常相似的，都是针对**范围不大**的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成**高低位**，位之间有递进关系。比较两个数，只需要比较高位，高位相同的再比较低位，且每一位的数据范围都不能太大，因为基数排序算法需要借助桶排序或计数排序来完成每一个位的排序工作。

#### 排序优化

|   类型   |      时间复杂度       | 是否稳定排序 | 是否原地排序 |
| :------: | :-------------------: | :----------: | :----------: |
| 冒泡排序 |        O(n^2)         |      ✅      |      ✅      |
| 插入排序 |        O(n^2)         |      ✅      |      ✅      |
| 选择排序 |        O(n^2)         |      ❌      |      ✅      |
| 快速排序 |       O(nlogn)        |      ❌      |      ✅      |
| 归并排序 |       O(nlogn)        |      ✅      |      ❌      |
| 计数排序 | O(n + k)(k: 数据范围) |      ✅      |      ❌      |
|  桶排序  |         O(n)          |      ✅      |      ❌      |
| 基数排序 |    O(dn)(n: 维度)     |      ✅      |      ❌      |

线性排序算法时间复杂度比较低，但是使用场景比较特殊。
如果对小规模数据进行排序，可以选择时间复杂度为 O(n^2)的算法。
如果对大规模数据进行排序，时间复杂度为 O(nlogn)的算法更加高效。

##### 快速排序优化

快速排序在最坏情况下的时间复杂度是 O(n^2)，比如数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，此时快排的时间复杂度就退化为 O(n^2)。实际上，这种 O(n^2)时间复杂度出现的主要原因还是因为我们的分区点选的不够合理。

最理想的分区点是：被分区点分开的两个分区中，数据的数量都差不多。

优化方案：1. 三数取中法；2. 随机法。
